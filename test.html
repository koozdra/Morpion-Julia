<!doctype html> <html lang="en"> <head> <meta charset="utf-8" /> <title>3D Chaos Game</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <style> html, body { margin: 0; height: 100%; background: #0b0d12; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: #e9eef7; } #ui { position: fixed; top: 10px; left: 10px; z-index: 10; background: rgba(20,24,33,0.8); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 10px 12px; display: grid; gap: 8px; grid-template-columns: auto auto; align-items: center; font-size: 14px; } #ui label { opacity: 0.9; } #ui input[type="range"] { width: 220px; } #ui input[type="number"] { width: 90px; background: #0f131b; color: #e9eef7; border: 1px solid rgba(255,255,255,0.12); border-radius: 4px; padding: 2px 6px; } #ui select { width: 220px; background: #0f131b; color: #e9eef7; border: 1px solid rgba(255,255,255,0.12); border-radius: 4px; padding: 2px 6px; } #ui button { background: linear-gradient(180deg,#2a5cff,#1f47cc); color: white; font-weight: 600; border: none; border-radius: 6px; padding: 8px 10px; cursor: pointer; } #ui button.secondary { background: #131826; border: 1px solid rgba(255,255,255,0.12); } #ui .row { grid-column: span 2; display:flex; gap:8px; } #footer { position: fixed; right: 10px; bottom: 10px; color: rgba(233,238,247,0.7); font-size: 12px; user-select: none; } canvas { display: block; } </style> </head> <body> <div id="ui"> <label for="shape">Attractor points</label> <select id="shape" title="Choose the set of attractor points"> <option value="pyramid" selected>Pyramid (Tetrahedron, 4)</option> <option value="cube">Cube (8)</option> <option value="dodecahedron">Dodecahedron (20)</option> <option value="icosahedron">Icosahedron (12)</option> </select>
<label for="pointsRange">Points (1–10000)</label>

<div style="display:flex; gap:8px; align-items:center;"> <input id="pointsRange" type="range" min="1" max="10000" step="1" value="8000"> <input id="pointsNumber" type="number" min="1" max="10000" step="1" value="8000"> </div>
<label for="intensityRange">Intensity (0–4)</label>

<div style="display:flex; gap:8px; align-items:center;"> <input id="intensityRange" type="range" min="0" max="4" step="0.01" value="0.5"> <input id="intensityNumber" type="number" min="0" max="4" step="0.01" value="0.5"> </div>
<label for="speedRange">Speed (steps/frame)</label>

<div style="display:flex; gap:8px; align-items:center;"> <input id="speedRange" type="range" min="1" max="20000" step="1" value="5000"> <input id="speedNumber" type="number" min="1" max="20000" step="1" value="5000"> </div> <div class="row"> <button id="resetBtn">Reset points</button> <button id="pauseBtn" class="secondary">Pause</button> <button id="shuffleBtn" class="secondary" title="Re-seed points within a sphere">Shuffle</button> <button id="toggleAttractorsBtn" class="secondary">Hide attractors</button> </div> </div> <div id="footer">Drag to rotate. Scroll to zoom.</div> <script type="module"> import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js'; import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js'; // Scene const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0d12); const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' }); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 5000); camera.position.set(0, 0, 14); scene.add(camera); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.06; controls.rotateSpeed = 0.9; controls.zoomSpeed = 1.2; controls.minDistance = 2; controls.maxDistance = 2000; const ambient = new THREE.AmbientLight(0xffffff, 0.25); scene.add(ambient); const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3, 4, 5); scene.add(dir); // UI const shapeEl = document.getElementById('shape'); const pointsRange = document.getElementById('pointsRange'); const pointsNumber = document.getElementById('pointsNumber'); const intensityRange = document.getElementById('intensityRange'); const intensityNumber = document.getElementById('intensityNumber'); const speedRange = document.getElementById('speedRange'); const speedNumber = document.getElementById('speedNumber'); const resetBtn = document.getElementById('resetBtn'); const pauseBtn = document.getElementById('pauseBtn'); const shuffleBtn = document.getElementById('shuffleBtn'); const toggleAttractorsBtn = document.getElementById('toggleAttractorsBtn'); // Params const params = { shape: shapeEl.value, points: clampInt(parseInt(pointsRange.value), 1, 10000), intensity: clamp(parseFloat(intensityRange.value), 0, 4), stepsPerFrame: clampInt(parseInt(speedRange.value), 1, 20000), attractorRadius: 5.0, particleSpread: 8.0, }; let attractorVectors = []; let attractorPoints; let particleGeom; let particlePoints; let positions; let paused = false; let attractorsVisible = true; // Helpers function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); } function clampInt(v, a, b) { return Math.max(a, Math.min(b, v|0)); } function randInt(max) { return (Math.random() * max) | 0; } function getAttractorVertices(name, radius=3) { const v = []; const phi = (1 + Math.sqrt(5)) / 2; const invPhi = 1 / phi; if (name === 'pyramid') { const base = [ [ 1, 1, 1], [-1, -1, 1], [-1, 1, -1], [ 1, -1, -1], ]; for (const p of base) v.push(new THREE.Vector3(p[0], p[1], p[2])); } else if (name === 'cube') { for (let x of [-1, 1]) for (let y of [-1, 1]) for (let z of [-1, 1]) { v.push(new THREE.Vector3(x, y, z)); } } else if (name === 'icosahedron') { const base = []; for (let s of [-1, 1]) for (let t of [-phi, phi]) base.push([0, s, t]); for (let s of [-1, 1]) for (let t of [-phi, phi]) base.push([s, t, 0]); for (let s of [-phi, phi]) for (let t of [-1, 1]) base.push([s, 0, t]); for (const p of base) v.push(new THREE.Vector3(p[0], p[1], p[2])); } else if (name === 'dodecahedron') { // 8 corners of a cube for (let x of [-1, 1]) for (let y of [-1, 1]) for (let z of [-1, 1]) { v.push(new THREE.Vector3(x, y, z)); } // 12 vertices from permutations of (0, ±1/φ, ±φ) const signs = [-1, 1]; const perms = (a, b) => [[0, a, b], [a, b, 0], [b, 0, a]]; for (let sy of signs) for (let sz of signs) { const a = sy * invPhi, b = sz * phi; for (const p of perms(a, b)) v.push(new THREE.Vector3(p[0], p[1], p[2])); } } else { return getAttractorVertices('cube', radius); } // Normalize to radius for (let i = 0; i < v.length; i++) v[i].normalize().multiplyScalar(radius); return v; } function createAttractors() { attractorVectors = getAttractorVertices(params.shape, params.attractorRadius); if (attractorPoints) { scene.remove(attractorPoints); attractorPoints.geometry.dispose(); attractorPoints.material.dispose(); } const attrGeom = new THREE.BufferGeometry(); const attrPos = new Float32Array(attractorVectors.length * 3); for (let i = 0; i < attractorVectors.length; i++) { const a = attractorVectors[i]; attrPos[i*3+0] = a.x; attrPos[i*3+1] = a.y; attrPos[i*3+2] = a.z; } attrGeom.setAttribute('position', new THREE.BufferAttribute(attrPos, 3)); const attrMat = new THREE.PointsMaterial({ color: 0xffd166, size: 10, sizeAttenuation: false }); attractorPoints = new THREE.Points(attrGeom, attrMat); attractorPoints.visible = attractorsVisible; scene.add(attractorPoints); } function createParticles() { if (particlePoints) { scene.remove(particlePoints); particleGeom.dispose(); particlePoints.material.dispose(); } particleGeom = new THREE.BufferGeometry(); positions = new Float32Array(params.points * 3); for (let i = 0; i < params.points; i++) { const r = Math.cbrt(Math.random()) * params.particleSpread; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta); positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta); positions[i*3+2] = r * Math.cos(phi); } particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3)); particleGeom.setDrawRange(0, params.points); const particlesMat = new THREE.PointsMaterial({ color: 0x7fb3ff, size: 0.05, sizeAttenuation: true, transparent: true, opacity: 0.95 }); particlePoints = new THREE.Points(particleGeom, particlesMat); scene.add(particlePoints); } function stepChaos(steps) { const n = params.points; const m = attractorVectors.length; const t = params.intensity; if (n === 0 || m === 0 || t === 0) return; for (let s = 0; s < steps; s++) { const i = randInt(n); const ai = randInt(m); const idx = i * 3; const ax = attractorVectors[ai].x; const ay = attractorVectors[ai].y; const az = attractorVectors[ai].z; const px = positions[idx+0]; const py = positions[idx+1]; const pz = positions[idx+2]; positions[idx+0] = px + (ax - px) * t; positions[idx+1] = py + (ay - py) * t; positions[idx+2] = pz + (az - pz) * t; } particleGeom.attributes.position.needsUpdate = true; } function animate() { requestAnimationFrame(animate); if (!paused) stepChaos(params.stepsPerFrame); controls.update(); renderer.render(scene, camera); } // UI bindings function syncPoints(fromRange) { if (fromRange) pointsNumber.value = pointsRange.value; else pointsRange.value = pointsNumber.value; params.points = clampInt(parseInt(pointsRange.value), 1, 10000); createParticles(); } function syncIntensity(fromRange) { if (fromRange) intensityNumber.value = intensityRange.value; else intensityRange.value = intensityNumber.value; params.intensity = clamp(parseFloat(intensityRange.value), 0, 4); } function syncSpeed(fromRange) { if (fromRange) speedNumber.value = speedRange.value; else speedRange.value = speedNumber.value; params.stepsPerFrame = clampInt(parseInt(speedRange.value), 1, 20000); } shapeEl.addEventListener('change', () => { params.shape = shapeEl.value; createAttractors(); createParticles(); }); pointsRange.addEventListener('input', () => syncPoints(true)); pointsNumber.addEventListener('change', () => syncPoints(false)); intensityRange.addEventListener('input', () => syncIntensity(true)); intensityNumber.addEventListener('change', () => syncIntensity(false)); speedRange.addEventListener('input', () => syncSpeed(true)); speedNumber.addEventListener('change', () => syncSpeed(false)); resetBtn.addEventListener('click', () => { createParticles(); }); pauseBtn.addEventListener('click', () => { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }); shuffleBtn.addEventListener('click', () => { for (let i = 0; i < params.points; i++) { const r = Math.cbrt(Math.random()) * params.particleSpread; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta); positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta); positions[i*3+2] = r * Math.cos(phi); } particleGeom.attributes.position.needsUpdate = true; }); toggleAttractorsBtn.addEventListener('click', () => { attractorsVisible = !attractorsVisible; if (attractorPoints) attractorPoints.visible = attractorsVisible; toggleAttractorsBtn.textContent = attractorsVisible ? 'Hide attractors' : 'Show attractors'; }); window.addEventListener('resize', () => { renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); }); createAttractors(); createParticles(); animate(); </script> </body> </html>